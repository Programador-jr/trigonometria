'use strict';

function Vnode(tag, key, attrs, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, events: undefined, instance: undefined}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node == null || typeof node === "boolean") return null
	if (typeof node === "object") return node
	return Vnode("#", undefined, undefined, String(node), undefined, undefined)
};
Vnode.normalizeChildren = function(input) {
	var children = [];
	if (input.length) {
		var isKeyed = input[0] != null && input[0].key != null;
		for (var i = 1; i < input.length; i++) {
			if ((input[i] != null && input[i].key != null) !== isKeyed) {
				throw new TypeError(
					isKeyed && (input[i] != null || typeof input[i] === "boolean")
						? "In fragments, vnodes must either all have keys or none have keys. You may wish to consider using an explicit keyed empty fragment, m.fragment({key: ...}), instead of a hole."
						: "In fragments, vnodes must either all have keys or none have keys."
				)
			}
		}
		for (var i = 0; i < input.length; i++) {
			children[i] = Vnode.normalize(input[i]);
		}
	}
	return children
};
var vnode = Vnode;

var hyperscriptVnode = function() {
	var attrs = arguments[this], start = this + 1, children;
	if (attrs == null) {
		attrs = {};
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {};
		start = this;
	}
	if (arguments.length === start + 1) {
		children = arguments[start];
		if (!Array.isArray(children)) children = [children];
	} else {
		children = [];
		while (start < arguments.length) children.push(arguments[start++]);
	}
	return vnode("", attrs.key, attrs, children)
};

var hasOwn = {}.hasOwnProperty;

var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
var selectorCache = {};
function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}
function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {};
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2];
		if (type === "" && value !== "") tag = value;
		else if (type === "#") attrs.id = value;
		else if (type === ".") classes.push(value);
		else if (match[3][0] === "[") {
			var attrValue = match[6];
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
			if (match[4] === "class") classes.push(attrValue);
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true;
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ");
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}
function execSelector(state, vnode$1) {
	var attrs = vnode$1.attrs;
	var children = vnode.normalizeChildren(vnode$1.children);
	var hasClass = hasOwn.call(attrs, "class");
	var className = hasClass ? attrs.class : attrs.className;
	vnode$1.tag = state.tag;
	vnode$1.attrs = null;
	vnode$1.children = undefined;
	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {};
		for (var key in attrs) {
			if (hasOwn.call(attrs, key)) newAttrs[key] = attrs[key];
		}
		attrs = newAttrs;
	}
	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key) && key !== "className" && !hasOwn.call(attrs, key)){
			attrs[key] = state.attrs[key];
		}
	}
	if (className != null || state.attrs.className != null) attrs.className =
		className != null
			? state.attrs.className != null
				? String(state.attrs.className) + " " + String(className)
				: className
			: state.attrs.className != null
				? state.attrs.className
				: null;
	if (hasClass) attrs.class = null;
	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			vnode$1.attrs = attrs;
			break
		}
	}
	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		vnode$1.text = children[0].children;
	} else {
		vnode$1.children = children;
	}
	return vnode$1
}
function hyperscript(selector) {
	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}
	var vnode$1 = hyperscriptVnode.apply(1, arguments);
	if (typeof selector === "string") {
		vnode$1.children = vnode.normalizeChildren(vnode$1.children);
		if (selector !== "[") return execSelector(selectorCache[selector] || compileSelector(selector), vnode$1)
	}
	vnode$1.tag = selector;
	return vnode$1
}
var hyperscript_1 = hyperscript;

var trust = function(html) {
	if (html == null) html = "";
	return vnode("<", undefined, undefined, html, undefined, undefined)
};

var fragment = function() {
	var vnode$1 = hyperscriptVnode.apply(0, arguments);
	vnode$1.tag = "[";
	vnode$1.children = vnode.normalizeChildren(vnode$1.children);
	return vnode$1
};

hyperscript_1.trust = trust;
hyperscript_1.fragment = fragment;
var hyperscript_1$1 = hyperscript_1;

const VOID_TAGS = [
  'area',
  'base',
  'br',
  'col',
  'command',
  'embed',
  'hr',
  'img',
  'input',
  'keygen',
  'link',
  'meta',
  'param',
  'source',
  'track',
  'wbr',
  '!doctype'
];
const COMPONENT_PROPS = [
  'oninit',
  'view',
  'oncreate',
  'onbeforeupdate',
  'onupdate',
  'onbeforeremove',
  'onremove'
];
function isArray (thing) {
  return (
    thing !== '[object Array]' &&
    Object.prototype.toString.call(thing) === '[object Array]'
  )
}
function isObject (thing) {
  return typeof thing === 'object'
}
function isFunction (thing) {
  return typeof thing === 'function'
}
function isClassComponent (thing) {
  return thing.prototype != null && typeof thing.prototype.view === 'function'
}
function camelToDash (str) {
  return str.replace(/\W+/g, '-').replace(/([a-z\d])([A-Z])/g, '$1-$2')
}
function removeEmpties (n) {
  return n !== ''
}
function omit (source, keys) {
  keys = keys || [];
  const res = Object.assign(Object.create(Object.getPrototypeOf(source)), source);
  keys.forEach(function (key) {
    if (key in res) {
      res[key] = null;
    }
  });
  return res
}
const copy = omit;
function escapeHtml (s, replaceDoubleQuote) {
  if (s === 'undefined') {
    s = '';
  }
  if (typeof s !== 'string') {
    s = s + '';
  }
  s = s
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
  if (replaceDoubleQuote) {
    return s.replace(/"/g, '&quot;')
  }
  return s
}
async function setHooks (component, vnode, hooks) {
  if (component.oninit) {
    await (component.oninit.call(vnode.state, vnode) || async function () {});
  }
  if (component.onremove) {
    vnode.state = vnode.state || {};
    hooks.push(component.onremove.bind(vnode.state, vnode));
  }
}
function createAttrString (view, escapeAttributeValue) {
  const attrs = view.attrs;
  if (!attrs || !Object.keys(attrs).length) {
    return ''
  }
  return Object.keys(attrs)
    .map(function (name) {
      const value = attrs[name];
      if (
        typeof value === 'undefined' ||
        value === null ||
        typeof value === 'function'
      ) {
        return
      }
      if (typeof value === 'boolean') {
        return value ? ' ' + name : ''
      }
      if (name === 'style') {
        if (!value) {
          return
        }
        let styles = attrs.style;
        if (isObject(styles)) {
          styles = Object.keys(styles)
            .map(function (property) {
              return styles[property] !== ''
                ? [camelToDash(property).toLowerCase(), styles[property]].join(
                  ':'
                )
                : ''
            })
            .filter(removeEmpties)
            .join(';');
        }
        return styles !== ''
          ? ' style="' + escapeAttributeValue(styles, true) + '"'
          : ''
      }
      if (name === 'href' && view.tag === 'use') {
        return ' xlink:href="' + escapeAttributeValue(value, true) + '"'
      }
      return (
        ' ' +
        (name === 'className' ? 'class' : name) +
        '="' +
        escapeAttributeValue(value, true) +
        '"'
      )
    })
    .join('')
}
async function createChildrenContent (view, options, hooks) {
  if (view.text != null) {
    return options.escapeString(view.text)
  }
  if (isArray(view.children) && !view.children.length) {
    return ''
  }
  return _render(view.children, options, hooks)
}
async function render (view, attrs, options) {
  options = options || {};
  if (view.view || isFunction(view)) {
    view = hyperscript_1$1(view, attrs);
  } else {
    options = attrs || {};
  }
  const hooks = [];
  const defaultOptions = {
    escapeAttributeValue: escapeHtml,
    escapeString: escapeHtml,
    strict: false
  };
  Object.keys(defaultOptions).forEach(function (key) {
    if (!options.hasOwnProperty(key)) options[key] = defaultOptions[key];
  });
  const result = await _render(view, options, hooks);
  hooks.forEach(function (hook) {
    hook({ state: {} });
  });
  return result
}
async function _render (view, options, hooks) {
  const type = typeof view;
  if (type === 'string') {
    return view
  }
  if (type === 'number' || type === 'boolean') {
    return view
  }
  if (!view) {
    return ''
  }
  if (isArray(view)) {
    let result = '';
    for (const v of view) {
      result += await _render(v, options, hooks);
    }
    return result
  }
  if (view.attrs) {
    await setHooks(view.attrs, view, hooks);
  }
  if (view.view || view.tag) {
    const vnode = { children: [].concat(view.children) };
    let component = view.view;
    if (isObject(view.tag)) {
      component = view.tag;
    } else if (isClassComponent(view.tag)) {
      component = new view.tag(vnode);
    } else if (isFunction(view.tag)) {
      component = view.tag(view);
    }
    if (component) {
      vnode.tag = copy(component);
      vnode.state = omit(component, COMPONENT_PROPS);
      vnode.attrs = component.attrs || view.attrs || {};
      await setHooks(component, vnode, hooks);
      return _render(component.view.call(vnode.state, vnode), options, hooks)
    }
  }
  if (view.tag === '<') {
    return '' + view.children
  }
  const children = await createChildrenContent(view, options, hooks);
  if (view.tag === '#') {
    return options.escapeString(children)
  }
  if (view.tag === '[') {
    return '' + children
  }
  if (
    !children &&
    (options.strict || VOID_TAGS.indexOf(view.tag.toLowerCase()) >= 0)
  ) {
    return (
      '<' +
      view.tag +
      createAttrString(view, options.escapeAttributeValue) +
      (options.strict ? '/' : '') +
      '>'
    )
  }
  return [
    '<',
    view.tag,
    createAttrString(view, options.escapeAttributeValue),
    '>',
    children,
    '</',
    view.tag,
    '>'
  ].join('')
}
var mithrilNodeRender = render;
var escapeHtml_1 = escapeHtml;
mithrilNodeRender.escapeHtml = escapeHtml_1;

exports.__moduleExports = mithrilNodeRender;
exports.default = mithrilNodeRender;
exports.escapeHtml = escapeHtml_1;
//# sourceMappingURL=index-78694c6b.js.map
